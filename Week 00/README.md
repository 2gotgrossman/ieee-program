## On The Self-Taught Software Engineer

Welcome! We're glad you could join us. You're in for a treat. 

### Our Goals
We have two goals in this course: To provide you with a base that will make you a top-notch software engineer and prepare you for *getting* a job in Silicon Valley.


### The Structure
We plan to structure this course as follows: We will meet on Mondays and Thursdays. 
- On Mondays, we will review (or learn if it is new for you!) key concepts on algorithms and data structures. We will also dive deep into an interesting Software Engineering topic. These will include Machine Learning, Big Data, System Design, Operating Systems, Parallel Programming, etc. 
- The goal of Mondays is to prepare you for interview questions and expose you to interesting areas of Software Engineering, which will guide your understanding of how software works and maybe inspire you to dive deep into one of these subjects.
- On Thursdays, we will do programming challenges. These will mostly be Interview Questions taken from 
[Cracking the Coding Interview, 6th Edition](http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/)
but will also include questions from the ICPC programming competition.

## How to get the most out of the course

- The way most of the veteran members of Software Engineering Club improved their skills is by **teaching yourself**. Coming to these classes is great: We'll teach you and provide you with a group of like-minded learners. However, you have to put in the time yourself.


I actually learned a lot about learning in this Coursera class I took in my last semester in college: 

- https://www.coursera.org/learn/learning-how-to-learn
- A [couple](https://pastebin.com/JNbGxvp) [summaries](https://workflowy.com/s/E9HW.jGUYboLrGj) of the course.

## How to get a job in Silicon Valley

To practice, get one of the recommended books with a list of exercises and hammer through it! Do all these problems, do one per day, or do two, or three, depending on how much time you have. There's no excuse to not do at least one of them a day until you feel comfortable enough to go to an interview feeling that you will make it. 

Success leads to confidence (conversely from what people believe), so the more you successfully solve problems the more confident you will be. Start small, build your skills, and you will make it. It's hard to properly emphasize just how helpful these books are.

- [Cracking the Coding Interview, 6th Edition](http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/)
- [Programming Interviews Exposed: Secrets to Landing Your Next Job, 2nd Edition](http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html)
- [Elements of Programming Interviews](https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836)



![Coding at the whiteboard - from HBO's Silicon Valley](https://dng5l3qzreal6.cloudfront.net/2016/Aug/coding_board_small-1470866369118.jpg)

### It's All About Discipline
- People put too much emphasis on IQ as opposed to emotional intelligence. After a certain level of IQ what really matters is dedication, passion,
and good discipline toward your work. Most of the famous genius engineers that we all know and heard of struggled with these topics too at one point,
but with the right discipline and passion they became really good at it by sticking to it. So never be discouraged!


## More on the topic

- [ ] [How to Work at Google: Prepare for an Engineering Interview (video)](https://www.youtube.com/watch?v=ko-KkSmp-Lk)
- [ ] [How to Work at Google - Candidate Coaching Session (video)](https://www.youtube.com/watch?v=oWbUtlUhwa8&feature=youtu.be)
- [ ] [Google Recruiters Share Technical Interview Tips (video)](https://www.youtube.com/watch?v=qc1owf2-220&feature=youtu.be)
- [ ] [How to Work at Google: Tech Resume Preparation (video)](https://www.youtube.com/watch?v=8npJLXkcmu8)
- [ ] A list of resources that was created by Google: [Google Careers: Technical Development Guide](https://www.google.com/about/careers/students/guide-to-technical-development.html)
- [ ] Cassidoo's getting a gig guide https://github.com/cassidoo/getting-a-gig
- [ ] Conference, you should definitely watch this [Made by Google announcement - Oct 2016 (video)](https://www.youtube.com/watch?v=q4y0KOeXViI)
- [ ] [Get That Job at Google](http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html)
- [ ] [How Google Search Dealt With Mobile](https://backchannel.com/how-google-search-dealt-with-mobile-33bc09852dc9)


## Interview Process & General Interview Prep




Talk points: 

### Interview Confidence

 - Be confident, but not arrogant

### Talk while you think, and code, explain everything that might be ambiguous

### If running out of time and need shortcuts, explain how you would not do the shortcut in a real scenario

### The interviewer is there because they want to hire someone, they are your friend not your enemy
- If they give you a hint, take it, don't be cocky


- [ ] [Gayle L McDowell - Cracking The Coding Interview (video)](https://www.youtube.com/watch?v=rEJzOhC5ZtQ)
- [ ] [Cracking the Coding Interview with Author Gayle Laakmann McDowell (video)](https://www.youtube.com/watch?v=aClxtDcdpsQ)
- [ ] ['How to Get a Job at the Big 4 - Amazon, Facebook, Google & Microsoft' (video)](https://www.youtube.com/watch?v=YJZCUhxNCv8)


Reading at home:
- [ ] [ABC: Always Be Coding](https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2#.4heg8zvm4)
- [ ] [Four Steps To Google Without A Degree](https://medium.com/always-be-coding/four-steps-to-google-without-a-degree-8f381aa6bd5e#.asalo1vfx)
- [ ] [Whiteboarding](https://medium.com/@dpup/whiteboarding-4df873dbba2e#.hf6jn45g1)
- [ ] [How Google Thinks About Hiring, Management And Culture](http://www.kpcb.com/blog/lessons-learned-how-google-thinks-about-hiring-management-and-culture)
- [ ] [Effective Whiteboarding during Programming Interviews](http://www.coderust.com/blog/2014/04/10/effective-whiteboarding-during-programming-interviews/)
- [ ] [Failing at Google Interviews](http://alexbowe.com/failing-at-google-interviews/)
- [_] http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/
- [ ] http://blog.codingforinterviews.com/best-programming-language-jobs/
- [ ] https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview
[See language resources here](programming-language-resources.md)


### Talk points -  Important advice: Pick One Language for the Interview

1:
You can use a language you are comfortable in to do the coding part of the interview, but for Google, these are solid choices:

- C++
- Java
- Python

You need to be very comfortable in the language, and be knowledgeable, so pick one, and do all the practice problems in that language. The more you practice
the more natural it will look like you feel at developing with the language, and that's important even though knowing the syntax itself isn't. But there
is a subconscious feeling we get by looking at the flow of someone working with something, and it's important to give interviewers that feeling




2. You won't remember it all

Use methods that will improve your memory for leaning, like spaced repetition, diffusive and focus modes of thinking, and etc (the learning how to learn course on Coursera was the most helpful resource on learning I used, but I continue to learn about this). But here's some basics stuff for you to get started:

- [Retaining Computer Science Knowledge](https://googleyasheck.com/retaining-computer-science-knowledge/)"

I personally don't use flash cards because I just scan my notes and upload to Drive so they are always accessible from my phone.


 2. Review, review, review

Again, though interviewers say they don't care about you memorizing details, they do want to see that you're really good at what you do, 
so if you easily recall the details, you will look much better. 


 4. Focus

One of my struggles was trying to do too much at the same time. I not only wanted to get a job at my favorite companies, despite not going to a school where those companies would recruit, I also wanted to take a bunch of online classes on things that wouldn't help me with the interview or school, but would benefit my personal learning goals and career (such as machine learning and even stuff like philosophy and history and business). It is indeed 
possible to be good at all these things, but you can't do them all at once. ****Forget multi-tasking. ***** just schedule time in your calendar and focus on
one thing at each time.  If you can dedicate 2 hours of focused time to this guide every day, you will go a long way.


3. Studying strategy:

For each subject covered, read and watch the content covering it, and then **implement** it. Please, don't skip the implementation part, this is the most
important one. Do not look at AVL trees and think "Oh we covered that in my algorithms class", the interviewer will never care what your class covered, 
he or she will ask you to implement it.

Also, write tests to make sure the code works. Most interviewers also ask you to do that. (Or at least run through test cases, but run them on paper, not 
simply by plugging the input in, because on the whiteboard they want to see if you can think through the code you just wrote.

So basically the process is: 
- understand an algorithm or subject
- implement it on paper (preferably whiteboard while talking through it as an interview)
- test it by running through examples by hand and thinking through it
- Implement on a computer and test with real inputs

Note: you should use standard libraries of python when practicing. Unless, for example, the question is sorting an array, then you should ask the interviewer
whether he expects you to use the standard library or implement it yourself. When in doubt, always ask for clarification! Don't make assumptions, and don't be afraid to ask questions, it's a good thing.


### Logistics

Not familiar with git yet? No worries http://rogerdudler.github.io/git-guide/ 
Or, if you are a University of Miami student, you have a free subcription to Lynda.com and you can take this quick start Git and GitHub course: https://www.lynda.com/Git-tutorials/Up-Running-Git-GitHub/409275-2.html

- [ ] [The Evolution of Search (video)](https://www.youtube.com/watch?v=mTBShTwCnD4)
- [ ] [How Search Works - Matt Cutts (video)](https://www.youtube.com/watch?v=BNHR6IQJGZs)
- [ ] [How Google makes improvements to its search algorithm (video)](https://www.youtube.com/watch?v=J5RZOU6vK4Q)

[ ] Start reading 20 minutes a day (or whatever fits your learning style/routine): 
[Book: How Google Works](https://www.amazon.com/How-Google-Works-Eric-Schmidt/dp/1455582344)
- [ ] [Google's Secret Study To Find Out Our Needs](https://backchannel.com/googles-secret-study-to-find-out-our-needs-eba8700263bf)
- [ ] [How Search Works - the story](https://www.google.com/insidesearch/howsearchworks/thestory/)
- [ ] [Phone Screen Questions](http://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions)
- [ ] [How Search Works](https://www.google.com/insidesearch/howsearchworks/)
- [ ] [Google Search Will Be Your Next Brain](https://backchannel.com/google-search-will-be-your-next-brain-5207c26e4523)
- [ ] [The Deep Mind Of Demis Hassabis](https://backchannel.com/the-deep-mind-of-demis-hassabis-156112890d8a)
- [ ] The myth of the Genius Programmer](https://www.youtube.com/watch?v=0SARbwvhupQ)



# Week 2

## Session 1 -  Algorithmic complexity / Big-O / Asymptotic analysis


### Talk points:

- You should be so comfortable (afte preparing and going through this) with algorithm complexity and Big-O notation that it is a natural process for you.
- You should be able to look at algorithms and spit out what the algorithm complexity is, and as the name might suggest otherwise, it is not complex at all. In fact it is a method for quickly managing complexity while getting a good evaluation on how the algorithm will run for large-scale applications.
- Imagine if you could do math, and simply get rid of all constants and lower order terms, and just say how the given function grows as the input grows, this is basically it.

- [ ] [Harvard CS50 - Asymptotic Notation (video)](https://www.youtube.com/watch?v=iOq5kSKqeR4)
- [ ] [Big O Notations (general quick tutorial) (video)](https://www.youtube.com/watch?v=V6mKVRU1evU)


Home reading
- [ ] [Cheat sheet](http://bigocheatsheet.com/)
- [ ] [Big O Notation (and Omega and Theta) - best mathematical explanation (video)](https://www.youtube.com/watch?v=ei-A_wy5Yxw&index=2&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN)
- [ ] Skiena: [video](https://www.youtube.com/watch?v=gSyDMtdPNpU&index=2&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b)
- [ ] [Orders of Growth (video)](https://class.coursera.org/algorithmicthink1-004/lecture/59)
- [ ] [Asymptotics (video)](https://class.coursera.org/algorithmicthink1-004/lecture/61)
- [ ] [A Gentle Introduction to Algorithm Complexity Analysis](http://discrete.gr/complexity/)
- [ ] [UC Berkeley Big O (video)](https://youtu.be/VIS4YDpuP98)
- [ ] [UC Berkeley Big Omega (video)](https://youtu.be/ca3e7UVmeUc)
- [ ] [Amortized Analysis (video)](https://www.youtube.com/watch?v=B3SpQZaAZP4&index=10&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN)

## Session 2 - An Overview of Data Structures and Algorithms

### Talk points - Data structures
   - Here I will give a lecture on how data structures and algorithms relate to Big-O, why choosing the appropriate data structures and algorithms
   - can have a significant impact on asymptoptic complexity (Big-O). Furthermore I will make a clear distinction between algorithms and data structures, 
   - and show that at the same time they work together, and that efficient algorithms make use of efficient data structures to boost performance. 

  - I will focus on the big picture, giving an overview of popular and extremely useful data structures and algorithms, and in the future sessions we  will dive into understanding the list of algorithms and data structures that students are expected to know.
    

### What is a data structure - With Examples
   - A data structure is exactly what it sounds like: a structure in a computer used to store and organize data in a form that will be useful.
    - As you begin to think about them, you can draw on a paper to come up with a picture of how the data is organized. When doing this, don't worry about the lower levels of how computer might handle memory, or physically store it, just worry about how the data is organized. For example: an array is a data structure, and you could represent it as [3, 2, 3, 4, 5], or (4, 5, 1, 2), it doesn't matter. As you progress in computer science, you will learn that we use notations such as [] to represent data structure of certain behaviors and () for another, but when the notation is introduced then you learn about it.
    - We have data structures in the real world, a bookshelf is a data structure, except that the data are books. A line in front of your favorite Disney ride is a queue, where the data is people. Queues are useful to preserve the order in which the elements arrived, in computing that's a very useful concept, for many systems, ranging from simple design of systems where users might be placed on a queue to chat with an agent, or even search algorithms which we will cover later, such as breadth-first search.

### Arrays
- So why do we need anything beyond arrays? Well, if you simply want to access or update an element in the array, they are very efficient for the job and it takes constant time to do so. But imagine if you wanted to insert an element in the beginning of the array. It would take O(n) operations to do so, since we have to shift all the elements to the end by one.
Video
- [Arrays (video)](https://www.coursera.org/learn/data-structures/lecture/OsBSF/arrays)


### List
- If we use a list however, which is a series of items (call them nodes) connected by links, all we have to do is make the new element point to the first element of the array. If we want to insert elsewhere, it's similar, we just need to get the preceeding element and have its link point to the new element, and have the new element point to the one after the original element. And it follows that this takes O(1), whereas retrieving the Nth element takes O(N)

Video: 
- [Singly Linked Lists (video)](https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists)
- [Core Linked Lists Vs Arrays (video)](https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/rjBs9/core-linked-lists-vs-arrays)
- [In The Real World Linked Lists Vs Arrays (video)](https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/QUaUd/in-the-real-world-lists-vs-arrays)


### Queue
- We use queues in our daily lives everywhere, in front of lines in our rollercoaster rides, medical systems, banking, finance, everywhere. And they come in all sorts of forms. The most basic takes only time in consideration, namely the first elements will be the first to be attended.
    - But there are also variations, such as priority queues, which take into consideration a series of factors. For example, in medical organ donation, we might consider the risk of death and urgency for the patient to receive a transplant (very complex system with some simplifications here, and in fact could be optimized with software). 
    - The same applies to computer science, where these queues are useful for designing these systems as well as supporting algorithms such as breadth-first search, and priority queues for A* search.
    
    Breadth-first search basically starts with an element and considers all the elements connected to it, before going to the next level. Whereas A*
    search looks into factors such as the cost of moving to the node and the estimated distance reduction to the goal.
    Video:
    - [ ] [Queue (video)](https://www.coursera.org/learn/data-structures/lecture/EShpq/queue)
    - [ ] [A* Pathfinding Tutorial (video)](https://www.youtube.com/watch?v=KNXfSOx4eEE)
    
### Hash Tables
 - Hash Tables are beautiful things and extremely useful in a very large and diverse domain of applications. If you have seen them before, and you are under the impression that they are complicated, just forget anything you know about them. They are quite straightforward:
      - Starting with the easy part, "table", we have a data structure that represents a table mapping a value generally represented as a string, to another value of any type. That's what a table is, and if hash tables were just the running time to find a value in the table would be O(n), and it wouldn't be very useful.
       -> That's the power of "hashing", where we take the key which is the value that maps to another, and process it with a function (for example adding the ascii characters modulo the number of entries in the table, which works but we will later see can be optimized substantially), and finds where in the table it belongs
       - Know how hash tables are implemented, but more importantly know how to use them to build new systems.
       
       
       Videos:
        - [ ] [Core Hash Tables (video)](https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/m7UuP/core-hash-tables)
        - [ ] [Data Structures (video)](https://www.coursera.org/learn/data-structures/home/week/3)
        - [ ] [Phone Book Problem (video)](https://www.coursera.org/learn/data-structures/lecture/NYZZP/phone-book-problem)
       
